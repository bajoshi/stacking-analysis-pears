import numpy as np
from scipy.integrate import simps, trapz

import os
import sys

import matplotlib.pyplot as plt

def plot_sfhs_verbose():

    # This will just make a plot to show what kind of 
    # SFHs are being considered within the MCMC sampling.
    num_models = 20
    t_end = 13.8  # age of Universe in Gyr
    total_mass_gen = 1.0  # i.e., normalizing to one solar # this can change later
    tstep = 1e5  # in years

    # Formation time array
    # Will choose some formation time randomly from this array
    tform = np.linspace(1.5, 13.5, num_models)  # In Gyr ago

    # Lists of burst parameters and timescales
    # This parameter is the ratio of stellar mass formed by the
    # burst mode to the stellar mass formed by the continuous mode.
    burst_param_list = np.logspace(np.log10(0.03), np.log10(4), num_models)
    burst_timescale_list = np.linspace(3e7, 3e8, num_models)  # in years # how long the burst will last
    num_bursts = np.arange(1, 6)  # any galaxy can only have between 1 to 5 bursts in its SFing lifetime

    # Create figure and set labels
    fig = plt.figure() 
    ax = fig.add_subplot(111)

    ax.set_xlabel(r'$\mathrm{Time\ [Gyr]}$', fontsize=14)
    ax.set_ylabel(r'$\mathrm{SFR\ [M_\odot/yr]}$', fontsize=14)

    for i in range(num_models): 
        gamma = np.random.random() # SFR timescale in 1/Gyr # uniformly distributed between 0 to 1
        current_tform = np.random.choice(tform) 
         
        # Create time array
        # t_end already defined above as the age of the Universe
        # Must compute t_start here because formation time is chosen as Gyr *ago*
        # i.e., formation time is not the same as t_start because of how I've
        # chosen to set up the time array.
        t_start = t_end - current_tform
        t = np.arange(t_start*1e9, t_end*1e9, tstep)  # in years 
        t /= 1e9  # converted back to Gyr because the SFR formula uses Gyr
    
        # Now add in bursts
        # Randomly choose parameter and timescale for bursts
        burst_param = np.random.choice(burst_param_list)
        burst_timescale = np.random.choice(burst_timescale_list)

        print("\n" + "Parameters chosen:")
        print("Formation time [Gyr ago]:", "{:.2f}".format(current_tform))
        print("SFR timescale gamma [1/Gyr]:", "{:.2f}".format(gamma))

        print("----------------")
        print("Burst parameter:", "{:.2f}".format(burst_param))
        print("Burst timescale [yr]:", "{:.2e}".format(burst_timescale))

        # stellar mass formed by bursts
        # this is a short back of the envelope calculation 
        # assuming that total_mass = continuous_mass + burst_mass
        burst_mass = burst_param * total_mass_gen / (1 + burst_param)

        print("Total mass that will be formed in bursts [M_sol]:", "{:.2f}".format(burst_mass))

        # Burst SFR
        sfr_burst_val = burst_mass / burst_timescale

        # When and how many bursts occur?
        # First choose over how many bursts to spread the creation of burst mass
        current_num_bursts = np.random.choice(num_bursts)
        # Now create an empty array to store SFRs for bursts
        sfr_burst = np.zeros(len(t))

        burst_times = np.sort(np.random.choice(t[:-1], size=current_num_bursts))  # starting times 

        print("Effective burst SFR (burst SFR if there was only one burst) [M_sol/yr]:", "{:.2e}".format(sfr_burst_val))
        print("Burst starting times [Gyr]:", burst_times)

        # Convert burst timescale to Gyr
        burst_timescale /= 1e9  # need it in Gyr for the part below

        for b in range(current_num_bursts):

            current_burst_time = burst_times[b]
            burst_time_idx = np.where((t > current_burst_time) & (t < current_burst_time + burst_timescale))[0]
            sfr_burst[burst_time_idx] = sfr_burst_val * 1e9 / current_num_bursts
            # The sfr_burst_val above needs to be multiplied by years per Gyr
            # because all the sfr arrays are in units of M_sol per Gyr. This is
            # because the time array is in units of Gyr, i.e., the units of an
            # individual element in each of these sfr arrays (because they are
            # pegged to the time array) are M_sol per Gyr.

        print("Total mass (num intg) generated by burst mode [M_sol]:", "{:.2f}".format(simps(y=sfr_burst, x=t)))

        """
        There is a subtlety here: all these computations are done 
        assuming that the burst is superimposed over the continuous mode.
        This means that while the burst is happening the continuous mode
        is still forming stars. Its not like the continous mode switches 
        off for the duration of the burst.
        """
    
        # Normalization of exponential SFR assuming total mass generated is one solar 
        continuous_mass = total_mass_gen - burst_mass
        sfr0 = (gamma * continuous_mass) / (1 - np.exp(-1 * gamma * (t_end - t_start)))
        # Now this should have the correct units of solar masses per year 

        print("----------------")
        print("Continuous SFR normalization [M_sol/yr]:", "{:.2f}".format(sfr0))
    
        sfr_cont = sfr0 * np.exp(-1 * gamma * (t - t_start))
        print("Starting and ending SFRs resp. for continuous mode [M_sol/yr]:", \
            "{:.2f}".format(sfr_cont[0]), "{:.2f}".format(sfr_cont[-1]))

        print("Total mass (num intg) generated by continuous mode [M_sol]:", "{:.2f}".format(simps(y=sfr_cont, x=t)))
    
        # Combine the continous and burst mode SFHs
        sfr = sfr_cont + sfr_burst

        print("----------------")
        total_mass_intg = simps(y=sfr, x=t)
        print("Total mass (num intg) generated overall [M_sol; should be very close to 1.0]:", "{:.2f}".format(total_mass_intg))
        print("----------------")
        print("\n")
    
        # ------------- Plotting ------------- # 
        ax.plot(t, sfr, color='gray', zorder=2) 
        ax.plot(t, sfr_cont, color='tab:blue', zorder=1)
        ax.plot(t, sfr_burst, color='tab:red', zorder=1)

        ax.minorticks_on()

        plt.show() 

        break
        plt.clf() 
        plt.cla() 
        plt.close() 

    return None

def main():

    plot_sfhs_verbose()

    return None

if __name__ == '__main__':
    main()
    sys.exit(0)